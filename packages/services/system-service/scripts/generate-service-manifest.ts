#!/usr/bin/env tsx
/**
 * Service Manifest Generator
 *
 * Generates a CommonJS-compatible service manifest from services.config.ts
 * that can be synchronously required() by platform-core's ServiceLocator.
 *
 * This solves the ESM/CommonJS interop issue and avoids circular dependencies.
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { fileURLToPath } from 'url';
// Direct source import to avoid build dependency during postinstall
import {
  SERVICES,
  type ServiceConfig,
  type ResourceRequirement,
} from '../../../../packages/platform-core/src/config/services-definition';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface ManifestResource {
  type: string;
  name: string;
  required: boolean;
}

interface ServiceManifestEntry {
  name: string;
  port: number;
  host: string;
  healthEndpoint: string;
  type?: string;
  tier?: string;
  resources?: ManifestResource[];
}

function generateManifest() {
  console.log('üîß Generating service manifest from services.config.ts...');

  const manifest: ServiceManifestEntry[] = SERVICES.map((service: ServiceConfig) => {
    const entry: ServiceManifestEntry = {
      name: service.name,
      port: service.port.development || service.port.internal,
      host: 'localhost',
      healthEndpoint:
        typeof service.healthCheck === 'string' ? service.healthCheck : service.healthCheck?.live || '/health',
      type: service.type,
      tier: service.tier,
    };

    if (service.resources && service.resources.length > 0) {
      entry.resources = service.resources.map((r: ResourceRequirement) => ({
        type: r.type,
        name: r.name,
        required: r.required,
      }));
    }

    return entry;
  });

  // Write to packages/shared location
  const outputDir = path.join(__dirname, '../../../shared');
  const outputPath = path.join(outputDir, 'service-manifest.cjs');

  // Ensure directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Compute a deterministic fingerprint of the manifest data (ignores formatting).
  // Prettier reformats the file (single-quotes, trailing commas), so comparing raw
  // strings fails. A hash of the canonical JSON is formatting-agnostic.
  const servicesJson = JSON.stringify(manifest, null, 2);
  const dataFingerprint = crypto.createHash('md5').update(JSON.stringify(manifest)).digest('hex');

  // Check if existing file has the same data fingerprint ‚Äî skip write if unchanged.
  // This prevents the pre-commit hook from creating a dirty timestamp diff on every commit.
  if (fs.existsSync(outputPath)) {
    const existing = fs.readFileSync(outputPath, 'utf-8');
    const existingFingerprintMatch = existing.match(/Data fingerprint: ([a-f0-9]+)/);
    if (existingFingerprintMatch && existingFingerprintMatch[1] === dataFingerprint) {
      console.log(`‚ÑπÔ∏è  Service manifest unchanged, skipping write: ${outputPath}`);
      console.log(`üì¶ Total services: ${manifest.length}`);
      return;
    }
  }

  const timestamp = new Date().toISOString();

  // Generate CommonJS module content
  const content = `/**
 * Auto-generated Service Manifest
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Generated from: @aiponge/platform-core services-definition
 * Generated at: ${timestamp}
 * Data fingerprint: ${dataFingerprint}
 *
 * This manifest is consumed by platform-core's ServiceLocator for
 * configuration discovery without circular dependencies.
 */

module.exports = {
  services: ${servicesJson},
  generated: '${timestamp}',
  version: '1.0.0'
};
`;

  fs.writeFileSync(outputPath, content, 'utf-8');

  console.log(`‚úÖ Service manifest generated: ${outputPath}`);
  console.log(`üì¶ Total services: ${manifest.length}`);
  console.log('   Services:', manifest.map(s => `${s.name}:${s.port}`).join(', '));
}

// Run the generator
try {
  generateManifest();
  process.exit(0);
} catch (error) {
  console.error('‚ùå Failed to generate service manifest:', error);
  process.exit(1);
}
